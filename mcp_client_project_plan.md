## Architecture

### Overview

•  Services.MCP : one-shot lifecycle and discovery orchestrator.
•  MCP.Supervisor : starts Hermes client instances per configured server.
•  Fnord.MCP.Client : a single Hermes client module that we instantiate multiple times (one per server).
•  MCP.Tools : converts discovered MCP tools into dynamic  AI.Tools  modules, patterned after  Frobs .
•  Cmd.Config.MCP : new  test  subcommand to validate configuration and discovery.

--------

## Implementation Details

### 1) Hermes Client Module

We define a single client module using Hermes, and start multiple instances with different  name  ids (one per server). The Hermes docs show this pattern.

File:  lib/mcp/fnord_client.ex

  defmodule MCP.FnordClient do
    @moduledoc false

    # Hermes client identity is set here (handshake identity), not the process id.
    @version (Application.spec(:fnord, :vsn) |> to_string())

    use Hermes.Client,
      name: "fnord",
      version: @version,
      protocol_version: "2024-11-05",
      capabilities: [:roots] # can expand later

    # We rely on Hermes.Client.* functions generated by this macro:
    # - get_server_info/0 or get_server_info/1
    # - list_tools/0 or list_tools/1
    # - call_tool/2 or call_tool/3 (with instance name as first arg if named)
  end

We will start multiple instances of  MCP.FnordClient  with different  :name  ids (e.g.,  :"mcp:server_name" ), and different  :transport  options per server.

### 2) Transport Mapping

We transform our config’s string transport into Hermes’s expected tuple. The docs show tuple style like  {:stdio, command: "...", args: [...]} .

  defmodule MCP.Transport do
    @moduledoc false

    @spec to_hermes_transport(map()) :: {:stdio | :streamable_http | :websocket, keyword()}
    def to_hermes_transport(%{"transport" => "stdio"} = cfg) do
      {:stdio,
       [
         command: cfg["command"],
         args: cfg["args"] || [],
         env: cfg["env"] || %{}
       ]}
    end

    def to_hermes_transport(%{"transport" => "streamable_http"} = cfg) do
      {:streamable_http,
       [
         base_url: cfg["base_url"],
         headers: cfg["headers"] || %{}
       ]}
    end

    def to_hermes_transport(%{"transport" => "websocket"} = cfg) do
      {:websocket,
       [
         base_url: cfg["base_url"],
         headers: cfg["headers"] || %{}
       ]}
    end
  end

This is trivial to extend in the future by adding a new clause. No config schema changes.

### 3) Supervisor for Clients

File:  lib/mcp/supervisor.ex

  defmodule MCP.Supervisor do
    use Supervisor

    @spec start_link(keyword()) :: Supervisor.on_start()
    def start_link(opts \\ []), do: Supervisor.start_link(__MODULE__, opts, name: __MODULE__)

    @impl true
    def init(_opts) do
      servers = effective_servers()
      children = Enum.map(servers, &client_child_spec/1)
      Supervisor.init(children, strategy: :one_for_one)
    end

    defp effective_servers() do
      settings = Settings.new()
      cfg = Settings.MCP.effective_config(settings)
      if cfg["enabled"], do: cfg["servers"], else: %{}
    end

    defp client_child_spec({server_name, server_cfg}) do
      {transport_kind, transport_opts} = MCP.Transport.to_hermes_transport(server_cfg)
      # Unique id for the instance; Hermes.Client supports a :name option
      # to run multiple instances from the same module.
      options = [name: instance_name(server_name), transport: {transport_kind, transport_opts}]
      Supervisor.child_spec({MCP.FnordClient, options}, id: {:mcp, server_name})
    end

    def instance_name(server_name), do: :"mcp:#{server_name}"
  end

### 4) Services.MCP: One-shot startup and discovery

File:  lib/services/mcp.ex

  defmodule Services.MCP do
    @moduledoc false
    @default_timeout_ms 30_000
    @max_timeout_ms 300_000

    alias MCP.Supervisor, as: MCPSupervisor

    @spec start() :: :ok
    def start() do
      # start supervisor for this invocation if enabled configs exist
      cfg = Settings.MCP.effective_config(Settings.new())
      if cfg["enabled"] && map_size(cfg["servers"]) > 0 do
        {:ok, _pid} = ensure_supervisor_started()
        discover_once()
      end
      :ok
    end

    defp ensure_supervisor_started() do
      case Process.whereis(MCPSupervisor) do
        nil -> MCPSupervisor.start_link([])
        pid -> {:ok, pid}
      end
    end

    # Only once per invocation
    def discover_once() do
      Services.Once.run(__MODULE__, fn ->
        do_discover()
      end)
    end

    defp do_discover() do
      cfg = Settings.MCP.effective_config(Settings.new())
      Enum.each(cfg["servers"], fn {server_name, _server_cfg} ->
        case safe_list_tools(server_name) do
          {:ok, tools} ->
            :ok = MCP.Tools.register_server_tools(server_name, tools)
          {:error, reason} ->
            # report detailed error once
            UI.warn(format_discovery_error(server_name, reason))
        end
      end)
    end

    defp safe_list_tools(server_name) do
      try do
        MCP.FnordClient.list_tools(MCP.Supervisor.instance_name(server_name))
      rescue
        e -> {:error, %{message: Exception.message(e), kind: :exception}}
      catch
        :exit, reason -> {:error, %{message: inspect(reason), kind: :exit}}
      end
    end

    defp format_discovery_error(server_name, reason) do
      Jason.encode!(%{
        mcp_discovery_error: %{
          server: server_name,
          reason: reason
        }
      }, pretty: true)
    end

    # Used by CLI test
    @spec test() :: map()
    def test() do
      cfg = Settings.MCP.effective_config(Settings.new())
      servers =
        cfg["servers"]
        |> Enum.map(fn {server, _} -> {server, test_server(server)} end)
        |> Enum.into(%{})

      %{
        status: "ok",
        servers: servers
      }
    end

    defp test_server(server_name) do
      info_result =
        case safe_info(server_name) do
          {:ok, info} -> %{status: "ok", info: info}
          {:error, reason} -> %{status: "error", error: reason}
        end

      tools_result =
        case safe_list_tools(server_name) do
          {:ok, tools} ->
            %{status: "ok", tools: Enum.map(tools, &tool_blurb/1)}
          {:error, reason} ->
            %{status: "error", error: reason}
        end

      Map.merge(info_result, tools_result)
    end

    defp tool_blurb(tool) do
      %{
        "name" => tool["name"],
        "description" => Map.get(tool, "description", "")
      }
    end

    defp safe_info(server_name) do
      try do
        MCP.FnordClient.get_server_info(MCP.Supervisor.instance_name(server_name))
      rescue
        e -> {:error, %{message: Exception.message(e), kind: :exception}}
      catch
        :exit, reason -> {:error, %{message: inspect(reason), kind: :exit}}
      end
    end
  end

Notes:

• We call  MCP.FnordClient.*(instance_id)  with the instance name to address the right process, consistent with Hermes docs that show calling functions with a named instance like  MyClient.call_tool(:name, "tool", args) .

### 5) MCP.Tools: Dynamic AI.Tools creation

File:  lib/mcp/tools.ex

  defmodule MCP.Tools do
    @moduledoc false

    # Register tool modules for a server based on its tool list.
    @spec register_server_tools(String.t(), list(map())) :: :ok
    def register_server_tools(server_name, tools) do
      Enum.each(tools, fn tool -> ensure_tool_module(server_name, tool) end)
      :ok
    end

    defp ensure_tool_module(server, %{"name" => tool_name} = tool_spec) do
      mod = module_name(server, tool_name)
      if Code.ensure_loaded?(mod) do
        :ok
      else
        create_tool_module(mod, server, tool_spec)
      end
    end

    def module_name(server, tool) do
      server_mod = server |> to_string() |> Macro.camelize()
      tool_mod = tool |> to_string() |> Macro.camelize()
      Module.concat([AI, Tools, MCP, server_mod, tool_mod])
    end

    defp create_tool_module(mod, server, tool_spec) do
      quoted =
        quote do
          @behaviour AI.Tools
          @server unquote(server)
          @tool unquote(tool_spec["name"])
          @spec_data unquote(Macro.escape(tool_spec))
          @default_timeout_ms 30_000
          @max_timeout_ms 300_000

          def async?(), do: true
          def is_available?(), do: true

          def spec() do
            %{
              "type" => "function",
              "name" => "#{@server}:#{@tool}",
              "description" => Map.get(@spec_data, "description", "MCP tool"),
              "parameters" => Map.get(@spec_data, "parameters", %{"type" => "object", "properties" => %{}})
            }
          end

          def read_args(args), do: {:ok, args}

          def ui_note_on_request(args),
            do: "MCP request #{@server}:#{@tool} with args: #{inspect(args)}"

          def ui_note_on_result(_args, _res),
            do: "MCP #{@server}:#{@tool} completed"

          def call(args) do
            timeout = Map.get(@spec_data, "timeout_ms", @default_timeout_ms)
            timeout = min(timeout, @max_timeout_ms)

            instance = MCP.Supervisor.instance_name(@server)
            case MCP.FnordClient.call_tool(instance, @tool, args, [timeout: timeout]) do
              {:ok, res} -> {:ok, res}
              {:error, reason} -> {:error, reason}
            end
          end
        end

      :code.purge(mod)
      :code.delete(mod)
      Module.create(mod, quoted, Macro.Env.location(__ENV__))
    end
  end

### 6) Hook into Services startup

Inside  lib/services.ex :

  defmodule Services do
    # ...
    def start_services() do
      # existing services start
      Services.MCP.start()
      # ...
    end
  end

### 7) CLI:  fnord config mcp test

Extend  lib/cmd/config/mcp.ex :

  defmodule Cmd.Config.MCP do
    # ...

    # Add spec in Cmd.Config.spec/0 for the new subcommand:
    # mcp test: name, about, options: --project, --global; optional: --server NAME in the future

    def run(opts, [:mcp, :test], _unknown) do
      # optional: respect --project or --global if you want scope; for now use effective
      Services.MCP.start()
      result = Services.MCP.test()
      result |> Jason.encode!(pretty: true) |> IO.puts()
    end
  end

--------

## Tool Call Lifecycle

1.  Services.start_services/0  calls  Services.MCP.start/0 .
2.  MCP.Supervisor  starts one Hermes client per server in effective config.
3.  Services.MCP.discover_once/0  lists tools for each server;  MCP.Tools  creates dynamic  AI.Tools  modules.
4. When code calls an MCP tool via  AI.Tools.call/2 :
  • The dynamic module validates args
  • Invokes  MCP.FnordClient.call_tool(instance, tool, args, [timeout: ...])
  • Returns normalized result


--------

## Error Handling and Diagnostics

• Discovery errors reported once per run via  Services.Once .
• Error payloads include transport kind and configuration context (e.g., base_url or command/args).
• Calls return  {:error, reason}  with server-provided message if available.
• Timeouts enforced with defaults and caps.

--------

## Relevant Files

• Existing:
  •  lib/settings/mcp.ex
  •  lib/cmd/config/mcp.ex
  •  lib/cmd/config/approvals.ex
• New to add:
  •  lib/mcp/fnord_client.ex
  •  lib/mcp/supervisor.ex
  •  lib/mcp/tools.ex
  •  lib/mcp/transport.ex  (mapping helper)
  •  lib/services/mcp.ex
  • Extend:
    •  lib/services.ex  to invoke  Services.MCP.start/0
    •  lib/cmd/config.ex  to add  mcp test  spec
    •  lib/cmd/config/mcp.ex  to handle  [:mcp, :test]



--------

## tl;dr

• One Hermes client module, multiple instances via supervisor, one per server.
• Map config transports to Hermes tuples:  {:stdio,...} ,  {:streamable_http,...} ,  {:websocket,...} .
• Discover tools once per run and expose them as dynamic  AI.Tools  modules.
• Treat enabling MCP servers as implicit approval; no per-call approvals.
• Add  fnord config mcp test  to validate connections and show available tools with detailed error info.
• Default timeout 30s, max 5m, override per server via  timeout_ms .
